# 内联汇编

内联汇编按格式分为两大类，一类是最简单的基本内联汇编，另一类是复杂一些的扩展内联汇编。

## AT&T语法

![20231014023241](https://cdn.jsdelivr.net/gh/WoodHolz/cloudimg/picture/20231014023241.png)

AT&T 的内存寻址是很独特的，它的内存寻址有固定的格式。

> segreg（段基址）：base_address(offset_address,index,size)

该格式对应的表达式为：

> segreg（段基址）：base_address+ offset_address+ index*size。
 
此表达式的格式和 Intel 32 位内存寻址中的基址变址寻址类似，Intel 的格式：

> segreg:[base+index*size+offset]

base_address 是基地址，可以为整数、变量名，可正可负。
offset_address 是偏移地址，index 是索引值，这两个必须是那 8 个通用寄存器之一。
size 是个长度，只能是 1、2、4、8（Intel 语法中也是只能乘以这 4 个数）。

### 直接寻址

此寻址中只有 base_address 项，即后面括号中的内容全不要，base_address 便为内存啦，比如 movl $255，0xc00008F0，或者用变量名：mov $6，var。

### 寄存器间接寻址

此寻址中只有 offset_address 项，即格式（offset_address），要记得，offset_address 只能是通用寄存器。寄存器中是地址，不要忘记格式中的圆括号，如 mov (%eax), %ebx。

### 寄存器相对寻址

此寻址中有 offset_address 项和 base_address 项，即格式为 base_address（offset_address）。这样得出的内存地址是基址+偏移地址之和。

各部分还是要按照格式填写，如 movb -4(%ebx),%al，功能是将地址（ebx-4）所指向的内存复制 1 字节到寄存器 al。

### 变址寻址

此类寻址称为变址的原因是含有通用格式中的变量 Index。因为 index 是 size 的倍数，所以有 index 的地方就有 size。既然是变址，只要有 index 和 size 就成了，base_address 和 offset_address 可有可无，注意，格式中没有的部分也要保留逗号来占位。

- 无base_address，无 offset_address：
movl %eax,(,%esi,2)
功能是将 eax 的值写入 esi*2 所指向的内存。

- 无 base_address，有 offset_address：
movl %eax,(%ebx,%esi,2)
功能是将 eax 的值写入 ebx+esi*2 所指向的内存。

- 有 base_address，无 offset_address：
movl %eax,base_value(,%esi,2)
功能是将 eax 的值写入 base_value+esi*2 所指向的内存。

- 有 base_address，有 offset_address：
movl %eax,base_value(%ebx,%esi,2)
功能是将 eax 的值写入 base_value+ebx+esi*2 所指向的内存。

## 基本内联汇编

基本内联汇编是最简单的内联形式，其格式为：

``` c
asm [volatile] ("assembly code")
```

关键字 asm 用于声明内联汇编表达式，这是内联汇编固定的部分，不可少。
asm 和__asm__是一样的，是由 gcc 定义的宏：#define __asm__ asm。

gcc 有个优化选项-O，可以指定优化级别。当用-O 来编译时，gcc 按照自己的意图优化代码，说不定就会把自己所写的代码修改了。关键字 volatile 是可选项，它告诉 gcc：“不要修改我写的汇编代码，请原样保留”。volatile 和__volatile__是一样的，是由 gcc 定义的宏：#define __volatile__ volatile。

"assembly code”是咱们所写的汇编代码，它必须位于圆括号中，而且必须用双引号引起来。这是格式要求，只要满足了这个格式 asm [volatile] (“”)，assembly code 甚至可以为空。

assembly code 的规则如下

1. 指令必须用双引号引起来，无论双引号中是一条指令或多条指令。
2. 一对双引号不能跨行，如果跨行需要在结尾用反斜杠'\'转义。
3. 指令之间用分号'；'、换行符'\n'或换行符加制表符'\n''\t'分隔。

### 实例

``` c
char* str = "hello inlineasm\n";
int count = 0;
int main() {
	asm("pusha;\
		movl $4,%eax; \
		movl $1, %ebx; \
		movl str,%ecx; \
		movl $16,%edx; \
		int $0x80; \
		mov %eax,count; \
		popa; \
		");
}
```
## 扩展内联汇编

* 在内联汇编代码插入点之前的 C 代码，其编译后也要被分配寄存器等资源，插入的汇编代码也要 使用寄存器，这是否会造成资源冲突？

在编译阶段由编译器优化，直接分配给寄存器或用寄存器缓存。

* 汇编语言如何访问 C 代码中的变量？

由于编译器无法预测用户的需求，这些只得让用户控制，故编译器采取的做法是它提供一个模板，让用户在模板中提出要求，其余工作由它负责实现。

``` c
asm [volatile] (“assembly code”:output : input : clobber/modify)
```

assembly code：还是用户写入的汇编指令，和基本内联汇编一样。

input 和 output 正是 C 为汇编提供输入参数和存储其输出的部分，这是汇编与 c 交互的关键。

output:output 用来指定汇编代码的数据如何输出给 C 代码使用。内嵌的汇编指令运行结束后，如果想将运行结果存储到 c 变量中，就用此项指定输出的位置。output 中每个操作数的格式为：

> “操作数修饰符约束名”（C 变量名）

其中的引号和圆括号不能少，操作数修饰符通常为等号'='。多个操作数之间用逗号'，'分隔。

input：input 用来指定 C 中数据如何输入给汇编使用。要想让汇编使用 C 中的变量作为参数，就要在此指定。input 中每个操作数的格式为：

> “[操作数修饰符] 约束名”（C 变量名）

其中的引号和圆括号不能少，操作数修饰符为可选项。多个操作数之间用逗号'，'分隔。

单独强调一下，以上的 output()和 input()括号中的是 C 代码中的变量，output（c 变量）和 input（c 变量）就像 C 语言中的函数，将 C 变量（值或变量地址）转换成汇编代码的操作数。

clobber/modify：汇编代码执行后会破坏一些内存或寄存器资源，通过此项通知编译器，可能造成寄存器或内存数据的破坏，这样 gcc 就知道哪些寄存器或内存需要提前保护起来。

assembly code 中引用的所有操作数其实是经过 gcc 转换后的复本，“原件”都是在 output 和 input 括号中的 c 变量。

### 寄存器约束

寄存器约束就是要求 gcc 使用哪个寄存器，将 input 或 output 中变量约束在某个寄存器中。常见的寄存器约束有：

a：表示寄存器 eax/ax/al
b：表示寄存器 ebx/bx/bl
c：表示寄存器 ecx/cx/cl
d：表示寄存器 edx/dx/dl
D：表示寄存器 edi/di
S：表示寄存器 esi/si
q：表示任意这 4 个通用寄存器之一：eax/ebx/ecx/edx
r：表示任意这 6 个通用寄存器之一：eax/ebx/ecx/edx/esi/edi
g：表示可以存放到任意地点（寄存器和内存）。相当于除了同 q 一样外，还可以让 gcc 安排在内存中
A：把 eax 和 edx 组合成 64 位整数
f：表示浮点寄存器
t：表示第 1 个浮点寄存器
u：表示第 2 个浮点寄存器

#### 实例

``` c
// 拓展内联汇编
#include <stdio.h>
int main()
{
    int in_a=1,in_b=333,out_sum;
    asm("addl %%ebx,%%eax":"=a"(out_sum):"a"(in_a),"b"(in_b));
    printf("sum is %d\n",out_sum);
    return 0;
}
```

``` c
// 基本内联汇编
#include <stdio.h>
int in_a=666,in_b=333,out_sum;
int main()
{
    asm("\
        pusha;\
        movl in_a,%eax;\
        movl in_b,%ebx;\
        addl %ebx,%eax;\
        movl %eax,out_sum;\
        popa;\
        ");
    printf("sum is %d\n",out_sum);
    return 0 ;
}
```

### 内存约束

内存约束是要求 gcc 直接将位于 input 和 output 中的 C 变量的内存地址作为内联汇编代码的操作数，不需要寄存器做中转，直接进行内存读写，也就是汇编代码的操作数是 C 变量的指针。

m：表示操作数可以使用任意一种内存形式。
o：操作数为内存变量，但访问它是通过偏移量的形式访问，即包含 offset_address 的格式。

