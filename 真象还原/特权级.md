# 特权级

## TSS

即 Task State Segment，意为任务状态段

![image-20231005164452361](https://cdn.jsdelivr.net/gh/WoodHolz/cloudimg/picture/image-20231005164452361.png)


## 门、调用门与 RPL 序

![image-20231017160256179](https://cdn.jsdelivr.net/gh/WoodHolz/cloudimg/picture/image-20231017160256179.png)

任务门描述符可以放在 GDT、LDT 和 IDT（中断描述符表，后面章节在介绍中断时大伙儿就清楚了）中，调用门可以位于 GDT、LDT 中，中断门和陷阱门仅位于 IDT 中。

任务门、调用门都可以用 call 和 jmp 指令直接调用，原因是这两个门描述符都位于描述符表中，要么是 GDT，要么是 LDT，访问它们同普通的段描述符是一样的，也必须要通过选择子，因此只要在 call 或jmp 指令后接任务门或调用门的选择子便可调用它们了。陷阱门和中断门只存在于 IDT 中，因此不能主动调用，只能由中断信号来触发调用。

![20231017201718](https://cdn.jsdelivr.net/gh/WoodHolz/cloudimg/picture/20231017201718.png)

### 调用门

call 和 jmp 指令后接调用门选择子为参数，以调用函数例程的形式实现从低特权向高特权转移，可用来实现系统调用。call 指令使用调用门可以实现向高特权代码转移，jmp 指令使用调用门只能实现向平级代码转移。

![20231017201757](https://cdn.jsdelivr.net/gh/WoodHolz/cloudimg/picture/20231017201757.png)

### 中断门

以 int 指令主动发中断的形式实现从低特权向高特权转移，Linux 系统调用便用此中断门实现。

### 陷阱门

以 int3 指令主动发中断的形式实现从低特权向高特权转移，这一般是编译器在调试时用。

### 任务门

任务以任务状态段 TSS 为单位，用来实现任务切换，它可以借助中断或指令发起。当中断发生时，如果对应的中断向量号是任务门，则会发起任务切换。也可以像调用门那样，用 call 或 jmp 指令后接任务门的选择子或任务 TSS 的选择子。

---

处理器对于门的特权检查，公式为：

（1）数值上 DPL_GATE≥CPL≥DPL_CODE（对应上面的 1）。

并且

（2）数值上 RPL≤DPL_GATE（对应上面的 2）。

对于 jmp 的特权级检查，公式如下：

（1）数值上 DPL_GATE≥CPL = DPL_CODE。

并且

（2）数值上 RPL≤DPL_GATE。

## IO 特权级

![image-20231017160348618](https://cdn.jsdelivr.net/gh/WoodHolz/cloudimg/picture/image-20231017160348618.png)

TSS 中如果有 I/O 位图的话，它将位于 TSS 的顶端，这就是 TSS 的实际尺寸并不固定的原因，当包括 I/O 位图时，其大小是“I/O 位图偏移地址”+8192+1 字节，结尾这个 1 字节是 I/O 位图中最后的 0xff。若不包括 I/O 位图，其大小则为最小尺寸 104 字节。由于 I/O 位图偏移地址并不固定，可以大于等于 104，所以在 TSS 中偏移 102 字节和 I/O 位图之间可能会有空闲区域。

I/O 位图位于 TSS 内，那它的地址必须是在 TSS 的尺寸范围之内，即地址的范围是在 TSS偏移（104 ～TSS 段界限 limit）之间，如果偏移地址不在此范围，即大于等于 TSS 段界限 limit（TSS 尺寸大小-1），则表明没有 I/O 位图。

处理器要求位图的最后一字节必须是 0xFF，此字节有两个作用。

第一，处理器允许 I/O 位图中不映射所有的端口，即 I/O 位图长度可以不足 8KB，但位图的最后一字节必须为 0xFF。如果在位图范围外的端口，处理器一律默认禁止访问。这样一来，如果位图最后一字节的 0xFF 属于全部 65536 个端口范围之内，字节各位全为 1 表示禁止访问此字节代表的全部端口，这并没什么过错。

第二，如果该字节已经超过了全部端口的范围，它并不用来映射端口，只是用来作为位图的边界标记，用于跨位图最后一个字节时的“余量字节”。避免越界访问 TSS 外的内存。
