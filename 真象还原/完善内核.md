# 完善内核

## 函数调用规定

使用栈来保持参数

在汇编语言中存在调用存入参数的顺序问题，需要对此做出约定

stdcall 约定 

``` mermaid
graph 
    a["调用者将参数从右到左压栈"]
    b["被调用者清理参数所占的栈空间"]
    c["具体是用`ret 立即数`顺便完成"]
    a --> b
    b -.- c
```

> 这里的清理并不需要将栈中内容置 0，将栈顶指针恢复即可

cdecl 约定

``` mermaid
graph TB
    a["调用者将参数从右到左压栈"]
    b["调用者清理参数所占的栈空间"]
    a --> b
```

## 混合编程

（1）单独的汇编代码文件与单独的 C 语言文件分别编译成目标文件后，一起链接成可执行程序。
（2）在 C 语言中嵌入汇编代码，直接编译生成可执行程序。

调用“系统调用”有两种方式。
（1）将系统调用指令封装为 c 库函数，通过库函数进行系统调用，操作简单。
（2）不依赖任何库函数，直接通过汇编指令 int 与操作系统通信。

当输入的参数小于等于 5 个时，Linux 用寄存器传递参数。当参数个数大于 5 个时，把参数按照顺序放入连续的内存区域，并将该区域的首地址放到 ebx 寄存器。
（1）ebx 存储第 1 个参数。
（2）ecx 存储第 2 个参数。
（3）edx 存储第 3 个参数。
（4）esi 存储第 4 个参数。
（5）edi 存储第 5 个参数。

---

在汇编语言中导出符号名用`global`关键字，这在之前说_start 时大伙已有所耳闻，`global`将符号导出为全局属性，对程序中的所有文件可见，这样其他外部文件中也可以引用被`global`导出的符号啦，无论该符号是函数，还是变量。

* 在汇编代码中导出符号供外部引用是用的关键字 global，引用外部文件的符号是用的关键字  extern。

* 在 C 代码中只要将符号定义为全局便可以被外部引用（一般情况下无需用额外关键字修饰，具体请参考 C 语言手册），引用外部符号时用 extern 声明即可。

---

# 中间的内容需要还原

---

#### 滚屏

什么时候需要？

1. 如果下次打印字符的坐标不小于 2000（在咱们的应用中顶多是等于 2000 的情况）

2. 新的光标值超出了屏幕右下角最后一个字符的位置。
3. 最后一行中任意位置有回车或换行符。

可用两个思路实现

1. 移动显存显示字符的初始地址，"自动"从该地址起向后显示2000个字符
1. 固定显存的首地址，更新缓存的2000个字符

采用思路2，设计步骤为：

1. 将第 1～24 行的内容整块搬到第 0～23 行，也就是把第 0 行的数据覆盖。
2. 再将第 24 行，也就是最后一行的字符用空格覆盖，这样它看上去是一个新的空行。
3. 把光标移到第 24 行也就是最后一行行首。

实现光标的回车 Carriage Return

``` mermaid
graph LR
	a["光标坐标对80求模（80*25的显示模式）"]
	b["行首坐标 == 光标坐标 - 余数"]
	a --> b
```

实现光标的换行 Line Feed

``` mermaid
graph LR
	a["下一行对应坐标 == 光标坐标 + 80"]
```

