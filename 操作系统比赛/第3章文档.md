当应用程序调用标准C库函数时，标准C库函数在user/lib中，如stdio.c、string.c等，stdio.c、string.c等文件中的标准C库调用ucore的系统调用，ucore的系统调用在user/lib/syscall.c中定义，user/lib/syscall.c中的系统调用函数会调用syscall，syscall是一个宏定义在user/lib/syscall.h中。user/lib/syscall.h中有几个宏，来获取系统调用名。如果在user/lib/syscall.c中调用syscall传递四个参数，最后就会转为调用__ syscall3。如果调用user/lib/syscall.c中调用syscall传递三个参数，最后就会转为调用__syscall2。

__ syscall1，__ syscall2，__ syscall3等函数定义在user/lib/arch/riscv/syscall_arch.h中，在__ syscall1、__ syscall2等函数中使用了ecall（异常的一种），会触发异常。然后执行异常处理函数（异常处理函数的地址在stvec中保存），即执行os/trampoline.S的uservec函数，该函数先将用户程序的各个寄存器保存，然后跳转到os/trap.c的usertrap函数，usertrap函数先读取sstatus寄存器，判断异常或中断原因，如果是系统调用就执行系统调用，然后恢复用户程序的寄存器，如果是其他异常，就直接去加载下一个应用程序，然后执行下一个应用程序。





1. 内核main函数先调用clean_bss()函数清空bss段。
2. 然后调用prco_init初始化进程池，本章的所有用户程序都会一次性加载到内存里，然后通过操作系统调度执行，所以抽象出来了一个线程的概念，每一个调入操作系统的用户程序都是一个线程，在将用户程序从硬盘调入内存的时候就直接为每一个用户程序分配一个线程。
3. 调用loader_init()初始化app_info_ptr指针，该指针和ch2相同，指向一个数组，该数组第一个元素n是用户程序的个数，后面有n个用户程序的地址
4. 调用trap_init()，开启内核态中断
5. 调用timer_init()开启时钟中断
6. 调用run_all_app()将所有用户程序加载到内存，并位每一个用户程序分配进程
7. 使用scheduler()开始调度应用程序，即开始调度进程。该函数调用了swtch函数，swtch函数定义在stitch.s中 ，是一个汇编函数，用来切换cpu所运行的进程。

